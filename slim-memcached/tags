!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
AE_ALL_EVENTS	ae.h	47;"	d
AE_DONT_WAIT	ae.h	48;"	d
AE_ERR	ae.h	39;"	d
AE_FILE_EVENTS	ae.h	45;"	d
AE_NOMORE	ae.h	50;"	d
AE_NONE	ae.h	41;"	d
AE_NOTUSED	ae.h	53;"	d
AE_OK	ae.h	38;"	d
AE_READABLE	ae.h	42;"	d
AE_SETSIZE	ae.h	36;"	d
AE_TIME_EVENTS	ae.h	46;"	d
AE_WRITABLE	ae.h	43;"	d
ANET_CONNECT_NONBLOCK	anet.c	127;"	d	file:
ANET_CONNECT_NONE	anet.c	126;"	d	file:
ANET_ERR	anet.h	35;"	d
ANET_ERR_LEN	anet.h	36;"	d
ANET_H	anet.h	32;"	d
ANET_OK	anet.h	34;"	d
CHUNK_ALIGN_BYTES	slabs.c	33;"	d	file:
DATA_BUFFER_SIZE	memcached.h	3;"	d
HASHPOWER	assoc.c	37;"	d	file:
IOV_LIST_HIGHWAT	memcached.h	21;"	d
IOV_LIST_INITIAL	memcached.h	13;"	d
IOV_MAX	memcached.c	60;"	d	file:
ITEM_DELETED	memcached.h	62;"	d
ITEM_LINKED	memcached.h	61;"	d
ITEM_LIST_HIGHWAT	memcached.h	20;"	d
ITEM_LIST_INITIAL	memcached.h	10;"	d
ITEM_SLABBED	memcached.h	65;"	d
ITEM_data	memcached.h	89;"	d
ITEM_key	memcached.h	85;"	d
ITEM_ntotal	memcached.h	90;"	d
ITEM_suffix	memcached.h	88;"	d
LARGEST_ID	items.c	23;"	d	file:
MAX_BUCKETS	memcached.h	173;"	d
MAX_SENDBUF_SIZE	memcached.h	7;"	d
MSG_LIST_HIGHWAT	memcached.h	22;"	d
MSG_LIST_INITIAL	memcached.h	16;"	d
NREAD_ADD	memcached.h	102;"	d
NREAD_REPLACE	memcached.h	104;"	d
NREAD_SET	memcached.h	103;"	d
POWER_BLOCK	slabs.c	32;"	d	file:
POWER_LARGEST	slabs.c	31;"	d	file:
POWER_SMALLEST	slabs.c	30;"	d	file:
READ_BUFFER_HIGHWAT	memcached.h	19;"	d
REALTIME_MAXDELTA	memcached.c	80;"	d	file:
TRANSMIT_COMPLETE	memcached.c	73;"	d	file:
TRANSMIT_HARD_ERROR	memcached.c	76;"	d	file:
TRANSMIT_INCOMPLETE	memcached.c	74;"	d	file:
TRANSMIT_SOFT_ERROR	memcached.c	75;"	d	file:
UDP_HEADER_SIZE	memcached.h	6;"	d
UDP_MAX_PAYLOAD_SIZE	memcached.h	5;"	d
UDP_READ_BUFFER_SIZE	memcached.h	4;"	d
_P1003_1B_VISIBLE	memcached.c	31;"	d	file:
__AE_H__	ae.h	34;"	d
__need_IOV_MAX	memcached.c	35;"	d	file:
_hashitem_before	assoc.c	/^static item** _hashitem_before (char *key) {$/;"	f	file:
_rfds	ae_select.c	/^    fd_set _rfds, _wfds;$/;"	m	struct:aeApiState	file:
_stritem	memcached.h	/^typedef struct _stritem {$/;"	s
_wfds	ae_select.c	/^    fd_set _rfds, _wfds;$/;"	m	struct:aeApiState	file:
add_iov	memcached.c	/^int add_iov(conn *c, const void *buf, int len) {$/;"	f
add_msghdr	memcached.c	/^int add_msghdr(conn *c)$/;"	f
aeAddMillisecondsToNow	ae.c	/^static void aeAddMillisecondsToNow(long long milliseconds, long *sec, long *ms) {$/;"	f	file:
aeApiAddEvent	ae_epoll.c	/^static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiAddEvent	ae_kqueue.c	/^static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiAddEvent	ae_select.c	/^static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiCreate	ae_epoll.c	/^static int aeApiCreate(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiCreate	ae_kqueue.c	/^static int aeApiCreate(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiCreate	ae_select.c	/^static int aeApiCreate(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiDelEvent	ae_epoll.c	/^static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int delmask) {$/;"	f	file:
aeApiDelEvent	ae_kqueue.c	/^static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiDelEvent	ae_select.c	/^static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:
aeApiFree	ae_epoll.c	/^static void aeApiFree(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiFree	ae_kqueue.c	/^static void aeApiFree(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiFree	ae_select.c	/^static void aeApiFree(aeEventLoop *eventLoop) {$/;"	f	file:
aeApiName	ae_epoll.c	/^static char *aeApiName(void) {$/;"	f	file:
aeApiName	ae_kqueue.c	/^static char *aeApiName(void) {$/;"	f	file:
aeApiName	ae_select.c	/^static char *aeApiName(void) {$/;"	f	file:
aeApiPoll	ae_epoll.c	/^static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {$/;"	f	file:
aeApiPoll	ae_kqueue.c	/^static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {$/;"	f	file:
aeApiPoll	ae_select.c	/^static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {$/;"	f	file:
aeApiState	ae_epoll.c	/^typedef struct aeApiState {$/;"	s	file:
aeApiState	ae_epoll.c	/^} aeApiState;$/;"	t	typeref:struct:aeApiState	file:
aeApiState	ae_kqueue.c	/^typedef struct aeApiState {$/;"	s	file:
aeApiState	ae_kqueue.c	/^} aeApiState;$/;"	t	typeref:struct:aeApiState	file:
aeApiState	ae_select.c	/^typedef struct aeApiState {$/;"	s	file:
aeApiState	ae_select.c	/^} aeApiState;$/;"	t	typeref:struct:aeApiState	file:
aeBeforeSleepProc	ae.h	/^typedef void aeBeforeSleepProc(struct aeEventLoop *eventLoop);$/;"	t
aeCreateEventLoop	ae.c	/^aeEventLoop *aeCreateEventLoop(void) {$/;"	f
aeCreateFileEvent	ae.c	/^int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask,$/;"	f
aeCreateTimeEvent	ae.c	/^long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds,$/;"	f
aeDeleteEventLoop	ae.c	/^void aeDeleteEventLoop(aeEventLoop *eventLoop) {$/;"	f
aeDeleteFileEvent	ae.c	/^void aeDeleteFileEvent(aeEventLoop *eventLoop, int fd, int mask)$/;"	f
aeDeleteTimeEvent	ae.c	/^int aeDeleteTimeEvent(aeEventLoop *eventLoop, long long id)$/;"	f
aeEventFinalizerProc	ae.h	/^typedef void aeEventFinalizerProc(struct aeEventLoop *eventLoop, void *clientData);$/;"	t
aeEventLoop	ae.h	/^typedef struct aeEventLoop {$/;"	s
aeEventLoop	ae.h	/^} aeEventLoop;$/;"	t	typeref:struct:aeEventLoop
aeFileEvent	ae.h	/^typedef struct aeFileEvent {$/;"	s
aeFileEvent	ae.h	/^} aeFileEvent;$/;"	t	typeref:struct:aeFileEvent
aeFileProc	ae.h	/^typedef void aeFileProc(struct aeEventLoop *eventLoop, int fd, void *clientData, int mask);$/;"	t
aeFiredEvent	ae.h	/^typedef struct aeFiredEvent {$/;"	s
aeFiredEvent	ae.h	/^} aeFiredEvent;$/;"	t	typeref:struct:aeFiredEvent
aeGetApiName	ae.c	/^char *aeGetApiName(void) {$/;"	f
aeGetTime	ae.c	/^static void aeGetTime(long *seconds, long *milliseconds)$/;"	f	file:
aeMain	ae.c	/^void aeMain(aeEventLoop *eventLoop) {$/;"	f
aeProcessEvents	ae.c	/^int aeProcessEvents(aeEventLoop *eventLoop, int flags)$/;"	f
aeSearchNearestTimer	ae.c	/^static aeTimeEvent *aeSearchNearestTimer(aeEventLoop *eventLoop)$/;"	f	file:
aeSetBeforeSleepProc	ae.c	/^void aeSetBeforeSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep) {$/;"	f
aeStop	ae.c	/^void aeStop(aeEventLoop *eventLoop) {$/;"	f
aeTimeEvent	ae.h	/^typedef struct aeTimeEvent {$/;"	s
aeTimeEvent	ae.h	/^} aeTimeEvent;$/;"	t	typeref:struct:aeTimeEvent
aeTimeProc	ae.h	/^typedef int aeTimeProc(struct aeEventLoop *eventLoop, long long id, void *clientData);$/;"	t
aeWait	ae.c	/^int aeWait(int fd, int mask, long long milliseconds) {$/;"	f
anetAccept	anet.c	/^int anetAccept(char *err, int serversock, char *ip, int *port)$/;"	f
anetNonBlock	anet.c	/^int anetNonBlock(char *err, int fd)$/;"	f
anetRead	anet.c	/^int anetRead(int fd, char *buf, int count)$/;"	f
anetResolve	anet.c	/^int anetResolve(char *err, char *host, char *ipbuf)$/;"	f
anetSetError	anet.c	/^static void anetSetError(char *err, const char *fmt, ...)$/;"	f	file:
anetSetSendBuffer	anet.c	/^int anetSetSendBuffer(char *err, int fd, int buffsize)$/;"	f
anetTcpConnect	anet.c	/^int anetTcpConnect(char *err, char *addr, int port)$/;"	f
anetTcpGenericConnect	anet.c	/^static int anetTcpGenericConnect(char *err, char *addr, int port, int flags)$/;"	f	file:
anetTcpKeepAlive	anet.c	/^int anetTcpKeepAlive(char *err, int fd)$/;"	f
anetTcpNoDelay	anet.c	/^int anetTcpNoDelay(char *err, int fd)$/;"	f
anetTcpNonBlockConnect	anet.c	/^int anetTcpNonBlockConnect(char *err, char *addr, int port)$/;"	f
anetTcpServer	anet.c	/^int anetTcpServer(char *err, int port, char *bindaddr)$/;"	f
anetWrite	anet.c	/^int anetWrite(int fd, char *buf, int count)$/;"	f
apidata	ae.h	/^    void *apidata; \/* This is used for polling API specific data *\/$/;"	m	struct:aeEventLoop
assoc_delete	assoc.c	/^void assoc_delete(char *key) {$/;"	f
assoc_find	assoc.c	/^item *assoc_find(char *key) {$/;"	f
assoc_init	assoc.c	/^void assoc_init(void) {$/;"	f
assoc_insert	assoc.c	/^int assoc_insert(char *key, item *it) {$/;"	f
beforesleep	ae.h	/^    aeBeforeSleepProc *beforesleep;$/;"	m	struct:aeEventLoop
binary	memcached.h	/^    int    binary;    \/* are we in binary mode *\/$/;"	m	struct:__anon2
bucket	memcached.h	/^    int    bucket;    \/* bucket number for the next command, if running as$/;"	m	struct:__anon2
buckets	memcached.c	/^int *buckets = 0; \/* bucket->generation array for a managed instance *\/$/;"	v
build_udp_headers	memcached.c	/^int build_udp_headers(conn *c) {$/;"	f
bytes_read	memcached.h	/^    unsigned long long bytes_read;$/;"	m	struct:stats
bytes_written	memcached.h	/^    unsigned long long bytes_written;$/;"	m	struct:stats
chunk_size	memcached.h	/^    int chunk_size;$/;"	m	struct:settings
clientData	ae.h	/^    void *clientData;$/;"	m	struct:aeFileEvent
clientData	ae.h	/^    void *clientData;$/;"	m	struct:aeTimeEvent
clock_handler	memcached.c	/^void clock_handler(int fd, short which, void *arg) {$/;"	f
clockevent	memcached.c	/^struct event clockevent;$/;"	v	typeref:struct:event
complete_nread	memcached.c	/^void complete_nread(conn *c) {$/;"	f
conn	memcached.h	/^} conn;$/;"	t	typeref:struct:__anon2
conn_cleanup	memcached.c	/^void conn_cleanup(conn *c) {$/;"	f
conn_close	memcached.c	/^void conn_close(conn *c) {$/;"	f
conn_closing	memcached.h	/^    conn_closing,    \/* closing this connection *\/$/;"	e	enum:conn_states
conn_free	memcached.c	/^static void conn_free(conn *c) {$/;"	f	file:
conn_init	memcached.c	/^void conn_init(void) {$/;"	f
conn_listening	memcached.h	/^    conn_listening,  \/* the socket which listens for connections *\/$/;"	e	enum:conn_states
conn_mwrite	memcached.h	/^    conn_mwrite      \/* writing out many items sequentially *\/$/;"	e	enum:conn_states
conn_new	memcached.c	/^conn *conn_new(int sfd, int init_state, int event_flags, int read_buffer_size,$/;"	f
conn_nread	memcached.h	/^    conn_nread,      \/* reading in a fixed number of bytes *\/$/;"	e	enum:conn_states
conn_read	memcached.h	/^    conn_read,       \/* reading in a command line *\/$/;"	e	enum:conn_states
conn_set_state	memcached.c	/^void conn_set_state(conn *c, int state) {$/;"	f
conn_shrink	memcached.c	/^void conn_shrink(conn *c) {$/;"	f
conn_states	memcached.h	/^enum conn_states {$/;"	g
conn_structs	memcached.h	/^    unsigned int  conn_structs;$/;"	m	struct:stats
conn_swallow	memcached.h	/^    conn_swallow,    \/* swallowing unnecessary bytes w\/o storing *\/$/;"	e	enum:conn_states
conn_write	memcached.h	/^    conn_write,      \/* writing out a simple response *\/$/;"	e	enum:conn_states
curr_bytes	memcached.h	/^    unsigned long long curr_bytes;$/;"	m	struct:stats
curr_conns	memcached.h	/^    unsigned int  curr_conns;$/;"	m	struct:stats
curr_items	memcached.h	/^    unsigned int  curr_items;$/;"	m	struct:stats
current_time	memcached.c	/^volatile rel_time_t current_time;$/;"	v
daemon	daemon.c	/^daemon(nochdir, noclose)$/;"	f
delcurr	memcached.c	/^static int delcurr;$/;"	v	file:
delete_handler	memcached.c	/^void delete_handler(int fd, short which, void *arg) {$/;"	f
deleteevent	memcached.c	/^struct event deleteevent;$/;"	v	typeref:struct:event
deltotal	memcached.c	/^static int deltotal;$/;"	v	file:
do_realloc	memcached.c	/^int do_realloc(void **orig, int newsize, int bytes_per_item, int *size) {$/;"	f
drive_machine	memcached.c	/^void drive_machine(conn *c) {$/;"	f
end	memcached.h	/^    void * end[0];$/;"	m	struct:_stritem
end_page_free	slabs.c	/^    unsigned int end_page_free; \/* number of items remaining at end of last alloced page *\/$/;"	m	struct:__anon1	file:
end_page_ptr	slabs.c	/^    void *end_page_ptr;         \/* pointer to next free item at end of page, or 0 *\/$/;"	m	struct:__anon1	file:
ensure_iov_space	memcached.c	/^int ensure_iov_space(conn *c) {$/;"	f
epfd	ae_epoll.c	/^    int epfd;$/;"	m	struct:aeApiState	file:
ev_flags	memcached.h	/^    short  ev_flags;$/;"	m	struct:__anon2
event	memcached.h	/^    struct event event;$/;"	m	struct:__anon2	typeref:struct:__anon2::event
event_handler	memcached.c	/^void event_handler(int fd, short which, void *arg) {$/;"	f
events	ae.h	/^    aeFileEvent events[AE_SETSIZE]; \/* Registered events *\/$/;"	m	struct:aeEventLoop
events	ae_epoll.c	/^    struct epoll_event events[AE_SETSIZE];$/;"	m	struct:aeApiState	typeref:struct:aeApiState::epoll_event	file:
events	ae_kqueue.c	/^    struct kevent events[AE_SETSIZE];$/;"	m	struct:aeApiState	typeref:struct:aeApiState::kevent	file:
evict_to_free	memcached.h	/^    int evict_to_free;$/;"	m	struct:settings
exptime	memcached.h	/^    rel_time_t      exptime;    \/* expire time *\/$/;"	m	struct:_stritem
factor	memcached.h	/^    double factor;          \/* chunk size growth factor *\/$/;"	m	struct:settings
fd	ae.h	/^    int fd;$/;"	m	struct:aeFiredEvent
finalizerProc	ae.h	/^    aeEventFinalizerProc *finalizerProc;$/;"	m	struct:aeTimeEvent
fired	ae.h	/^    aeFiredEvent fired[AE_SETSIZE]; \/* Fired events *\/$/;"	m	struct:aeEventLoop
freeconns	memcached.c	/^conn **freeconns;$/;"	v
freecurr	memcached.c	/^int freecurr;$/;"	v
freetotal	memcached.c	/^int freetotal;$/;"	v
gen	memcached.h	/^    int    gen;       \/* generation requested for the bucket *\/$/;"	m	struct:__anon2
get_cmds	memcached.h	/^    unsigned long long  get_cmds;$/;"	m	struct:stats
get_hits	memcached.h	/^    unsigned long long  get_hits;$/;"	m	struct:stats
get_item	memcached.c	/^item *get_item(char *key) {$/;"	f
get_item_notedeleted	memcached.c	/^item *get_item_notedeleted(char *key, int *delete_locked) {$/;"	f
get_misses	memcached.h	/^    unsigned long long  get_misses;$/;"	m	struct:stats
grow_slab_list	slabs.c	/^static int grow_slab_list (unsigned int id) {$/;"	f	file:
h_next	memcached.h	/^    struct _stritem *h_next;    \/* hash chain next *\/$/;"	m	struct:_stritem	typeref:struct:_stritem::_stritem
hash	assoc.c	/^ub4 hash( k, length, initval)$/;"	f
hashmask	assoc.c	40;"	d	file:
hashsize	assoc.c	39;"	d	file:
hashtable	assoc.c	/^static item** hashtable = 0;$/;"	v	file:
hdrbuf	memcached.h	/^    unsigned char *hdrbuf; \/* udp packet headers *\/$/;"	m	struct:__anon2
hdrsize	memcached.h	/^    int    hdrsize;   \/* number of headers' worth of space is allocated *\/$/;"	m	struct:__anon2
heads	items.c	/^static item *heads[LARGEST_ID];$/;"	v	file:
icurr	memcached.h	/^    item   **icurr;$/;"	m	struct:__anon2
id	ae.h	/^    long long id; \/* time event identifier. *\/$/;"	m	struct:aeTimeEvent
ileft	memcached.h	/^    int    ileft;$/;"	m	struct:__anon2
ilist	memcached.h	/^    item   **ilist;   \/* list of items to write out *\/$/;"	m	struct:__anon2
interface	memcached.h	/^    struct in_addr interface;$/;"	m	struct:settings	typeref:struct:settings::in_addr
iov	memcached.h	/^    struct iovec *iov;$/;"	m	struct:__anon2	typeref:struct:__anon2::iovec
iovsize	memcached.h	/^    int    iovsize;   \/* number of elements allocated in iov[] *\/$/;"	m	struct:__anon2
iovused	memcached.h	/^    int    iovused;   \/* number of elements used in iov[] *\/$/;"	m	struct:__anon2
isize	memcached.h	/^    int    isize;$/;"	m	struct:__anon2
it_flags	memcached.h	/^    unsigned char   it_flags;   \/* ITEM_* above *\/$/;"	m	struct:_stritem
item	memcached.h	/^    void   *item;     \/* for commands set\/add\/replace  *\/$/;"	m	struct:__anon2
item	memcached.h	/^} item;$/;"	t	typeref:struct:_stritem
item_alloc	items.c	/^item *item_alloc(char *key, int flags, rel_time_t exptime, int nbytes) {$/;"	f
item_cachedump	items.c	/^char *item_cachedump(unsigned int slabs_clsid, unsigned int limit, unsigned int *bytes) {$/;"	f
item_comm	memcached.h	/^    int    item_comm; \/* which one is it: set\/add\/replace *\/$/;"	m	struct:__anon2
item_delete_lock_over	memcached.c	/^int item_delete_lock_over (item *it) {$/;"	f
item_free	items.c	/^void item_free(item *it) {$/;"	f
item_init	items.c	/^void item_init(void) {$/;"	f
item_link	items.c	/^int item_link(item *it) {$/;"	f
item_link_q	items.c	/^void item_link_q(item *it) { \/* item is the new head *\/$/;"	f
item_make_header	items.c	/^int item_make_header(char *key, int flags, int nbytes,$/;"	f
item_remove	items.c	/^void item_remove(item *it) {$/;"	f
item_replace	items.c	/^int item_replace(item *it, item *new_it) {$/;"	f
item_size_ok	items.c	/^int item_size_ok(char *key, int flags, int nbytes) {$/;"	f
item_stats	items.c	/^void item_stats(char *buffer, int buflen) {$/;"	f
item_stats_sizes	items.c	/^char* item_stats_sizes(int *bytes) {$/;"	f
item_unlink	items.c	/^void item_unlink(item *it) {$/;"	f
item_unlink_q	items.c	/^void item_unlink_q(item *it) {$/;"	f
item_update	items.c	/^void item_update(item *it) {$/;"	f
killing	slabs.c	/^    unsigned int killing;  \/* index+1 of dying slab, or zero if none *\/$/;"	m	struct:__anon1	file:
kqfd	ae_kqueue.c	/^    int kqfd;$/;"	m	struct:aeApiState	file:
l_socket	memcached.c	/^int l_socket=0;$/;"	v
list_size	slabs.c	/^    unsigned int list_size; \/* size of prev array *\/$/;"	m	struct:__anon1	file:
main	memcached.c	/^int main (int argc, char **argv) {$/;"	f
managed	memcached.h	/^    int managed;          \/* if 1, a tracker manages virtual buckets *\/$/;"	m	struct:settings
mask	ae.h	/^    int mask; \/* one of AE_(READABLE|WRITABLE) *\/$/;"	m	struct:aeFileEvent
mask	ae.h	/^    int mask;$/;"	m	struct:aeFiredEvent
maxbytes	memcached.h	/^    size_t maxbytes;$/;"	m	struct:settings
maxconns	memcached.h	/^    int maxconns;$/;"	m	struct:settings
maxfd	ae.h	/^    int maxfd;$/;"	m	struct:aeEventLoop
maximize_sndbuf	memcached.c	/^void maximize_sndbuf(int sfd) {$/;"	f
mem_limit	slabs.c	/^static size_t mem_limit = 0;$/;"	v	file:
mem_malloced	slabs.c	/^static size_t mem_malloced = 0;$/;"	v	file:
mix	assoc.c	42;"	d	file:
msgbytes	memcached.h	/^    int    msgbytes;  \/* number of bytes in current msg *\/$/;"	m	struct:__anon2
msgcurr	memcached.h	/^    int    msgcurr;   \/* element in msglist[] being transmitted now *\/$/;"	m	struct:__anon2
msglist	memcached.h	/^    struct msghdr *msglist;$/;"	m	struct:__anon2	typeref:struct:__anon2::msghdr
msgsize	memcached.h	/^    int    msgsize;   \/* number of elements allocated in msglist[] *\/$/;"	m	struct:__anon2
msgused	memcached.h	/^    int    msgused;   \/* number of elements used in msglist[] *\/$/;"	m	struct:__anon2
nbytes	memcached.h	/^    int             nbytes;     \/* size of data *\/$/;"	m	struct:_stritem
new_socket	memcached.c	/^int new_socket(int is_udp) {$/;"	f
new_socket_unix	memcached.c	/^int new_socket_unix(void) {$/;"	f
next	ae.h	/^    struct aeTimeEvent *next;$/;"	m	struct:aeTimeEvent	typeref:struct:aeTimeEvent::aeTimeEvent
next	memcached.h	/^    struct _stritem *next;$/;"	m	struct:_stritem	typeref:struct:_stritem::_stritem
nkey	memcached.h	/^    unsigned char   nkey;       \/* key length, w\/terminating null and padding *\/$/;"	m	struct:_stritem
nsuffix	memcached.h	/^    unsigned char   nsuffix;    \/* length of flags-and-length string *\/$/;"	m	struct:_stritem
oldest_live	memcached.h	/^    rel_time_t oldest_live; \/* ignore existing items older than this *\/$/;"	m	struct:settings
out_string	memcached.c	/^void out_string(conn *c, char *str) {$/;"	f
perslab	slabs.c	/^    unsigned int perslab;   \/* how many items per slab *\/$/;"	m	struct:__anon1	file:
port	memcached.h	/^    int port;$/;"	m	struct:settings
power_largest	slabs.c	/^static int power_largest;$/;"	v	file:
pre_gdb	memcached.c	/^void pre_gdb () {$/;"	f
prev	memcached.h	/^    struct _stritem *prev;$/;"	m	struct:_stritem	typeref:struct:_stritem::_stritem
processTimeEvents	ae.c	/^static int processTimeEvents(aeEventLoop *eventLoop) {$/;"	f	file:
process_command	memcached.c	/^void process_command(conn *c, char *command) {$/;"	f
process_stat	memcached.c	/^void process_stat(conn *c, char *command) {$/;"	f
rbuf	memcached.h	/^    char   *rbuf;   \/* buffer to read commands into *\/$/;"	m	struct:__anon2
rbytes	memcached.h	/^    int    rbytes;  \/* how much data, starting from rcur, do we have unparsed *\/$/;"	m	struct:__anon2
rcurr	memcached.h	/^    char   *rcurr;  \/* but if we parsed some already, this is where we stopped *\/$/;"	m	struct:__anon2
realtime	memcached.c	/^rel_time_t realtime(time_t exptime) {$/;"	f
refcount	memcached.h	/^    unsigned short  refcount;$/;"	m	struct:_stritem
rel_time_t	memcached.h	/^typedef unsigned int rel_time_t;$/;"	t
remove_pidfile	memcached.c	/^void remove_pidfile(char *pid_file) {$/;"	f
request_addr	memcached.h	/^    struct sockaddr request_addr; \/* Who sent the most recent request *\/$/;"	m	struct:__anon2	typeref:struct:__anon2::sockaddr
request_addr_size	memcached.h	/^    socklen_t request_addr_size;$/;"	m	struct:__anon2
request_id	memcached.h	/^    int    request_id; \/* Incoming UDP request ID, if this is a UDP "connection" *\/$/;"	m	struct:__anon2
rfds	ae_select.c	/^    fd_set rfds, wfds;$/;"	m	struct:aeApiState	file:
rfileProc	ae.h	/^    aeFileProc *rfileProc;$/;"	m	struct:aeFileEvent
ritem	memcached.h	/^    char   *ritem;  \/* when we read in an item's value, it goes here *\/$/;"	m	struct:__anon2
rlbytes	memcached.h	/^    int    rlbytes;$/;"	m	struct:__anon2
rsize	memcached.h	/^    int    rsize;   \/* total allocated size of rbuf *\/$/;"	m	struct:__anon2
save_pid	memcached.c	/^void save_pid(pid_t pid,char *pid_file) {$/;"	f
sbytes	memcached.h	/^    int    sbytes;    \/* how many bytes to swallow *\/$/;"	m	struct:__anon2
server_socket	memcached.c	/^int server_socket(int port, int is_udp) {$/;"	f
server_socket_unix	memcached.c	/^int server_socket_unix(char *path) {$/;"	f
set_cmds	memcached.h	/^    unsigned long long  set_cmds;$/;"	m	struct:stats
set_current_time	memcached.c	/^void set_current_time () {$/;"	f
settings	memcached.c	/^struct settings settings;$/;"	v	typeref:struct:settings
settings	memcached.h	/^struct settings {$/;"	s
settings_init	memcached.c	/^void settings_init(void) {$/;"	f
sfd	memcached.h	/^    int    sfd;$/;"	m	struct:__anon2
sig_handler	memcached.c	/^void sig_handler(int sig) {$/;"	f
size	slabs.c	/^    unsigned int size;      \/* sizes of items *\/$/;"	m	struct:__anon1	file:
sizes	items.c	/^unsigned int sizes[LARGEST_ID];$/;"	v
sl_curr	slabs.c	/^    unsigned int sl_curr;   \/* first free slot *\/$/;"	m	struct:__anon1	file:
sl_total	slabs.c	/^    unsigned int sl_total;  \/* size of previous array *\/$/;"	m	struct:__anon1	file:
slab_list	slabs.c	/^    void **slab_list;       \/* array of slab pointers *\/$/;"	m	struct:__anon1	file:
slabclass	slabs.c	/^static slabclass_t slabclass[POWER_LARGEST+1];$/;"	v	file:
slabclass_t	slabs.c	/^} slabclass_t;$/;"	t	typeref:struct:__anon1	file:
slabs	slabs.c	/^    unsigned int slabs;     \/* how many slabs were allocated for this class *\/$/;"	m	struct:__anon1	file:
slabs_alloc	slabs.c	/^void *slabs_alloc(size_t size) {$/;"	f
slabs_clsid	memcached.h	/^    unsigned char   slabs_clsid;\/* which slab class we're in *\/$/;"	m	struct:_stritem
slabs_clsid	slabs.c	/^unsigned int slabs_clsid(size_t size) {$/;"	f
slabs_free	slabs.c	/^void slabs_free(void *ptr, size_t size) {$/;"	f
slabs_init	slabs.c	/^void slabs_init(size_t limit, double factor) {$/;"	f
slabs_newslab	slabs.c	/^int slabs_newslab(unsigned int id) {$/;"	f
slabs_preallocate	slabs.c	/^void slabs_preallocate (unsigned int maxslabs) {$/;"	f
slabs_reassign	slabs.c	/^int slabs_reassign(unsigned char srcid, unsigned char dstid) {$/;"	f
slabs_stats	slabs.c	/^char* slabs_stats(int *buflen) {$/;"	f
slots	slabs.c	/^    void **slots;           \/* list of item ptrs *\/$/;"	m	struct:__anon1	file:
socketpath	memcached.h	/^    char *socketpath;   \/* path to unix socket if using local socket *\/$/;"	m	struct:settings
started	memcached.h	/^    time_t        started;          \/* when the process was started *\/$/;"	m	struct:stats
state	memcached.h	/^    int    state;$/;"	m	struct:__anon2
stats	memcached.c	/^struct stats stats;$/;"	v	typeref:struct:stats
stats	memcached.h	/^struct stats {$/;"	s
stats_init	memcached.c	/^void stats_init(void) {$/;"	f
stats_reset	memcached.c	/^void stats_reset(void) {$/;"	f
stop	ae.h	/^    int stop;$/;"	m	struct:aeEventLoop
tails	items.c	/^static item *tails[LARGEST_ID];$/;"	v	file:
time	memcached.h	/^    rel_time_t      time;       \/* least recent access *\/$/;"	m	struct:_stritem
timeEventHead	ae.h	/^    aeTimeEvent *timeEventHead;$/;"	m	struct:aeEventLoop
timeEventNextId	ae.h	/^    long long timeEventNextId;$/;"	m	struct:aeEventLoop
timeProc	ae.h	/^    aeTimeProc *timeProc;$/;"	m	struct:aeTimeEvent
todelete	memcached.c	/^static item **todelete = 0;$/;"	v	file:
total_conns	memcached.h	/^    unsigned int  total_conns;$/;"	m	struct:stats
total_items	memcached.h	/^    unsigned int  total_items;$/;"	m	struct:stats
transmit	memcached.c	/^int transmit(conn *c) {$/;"	f
try_read_command	memcached.c	/^int try_read_command(conn *c) {$/;"	f
try_read_network	memcached.c	/^int try_read_network(conn *c) {$/;"	f
try_read_udp	memcached.c	/^int try_read_udp(conn *c) {$/;"	f
u_socket	memcached.c	/^int u_socket=-1;$/;"	v
ub1	assoc.c	/^typedef  unsigned       char ub1;   \/* unsigned 1-byte quantities *\/$/;"	t	file:
ub4	assoc.c	/^typedef  unsigned long  int  ub4;   \/* unsigned 4-byte quantities *\/$/;"	t	file:
udp	memcached.h	/^    int    udp;       \/* 1 if this is a UDP "connection" *\/$/;"	m	struct:__anon2
udpport	memcached.h	/^    int udpport;$/;"	m	struct:settings
update_event	memcached.c	/^int update_event(conn *c, int new_flags) {$/;"	f
usage	memcached.c	/^void usage(void) {$/;"	f
usage_license	memcached.c	/^void usage_license(void) {$/;"	f
verbose	memcached.h	/^    int verbose;$/;"	m	struct:settings
wbuf	memcached.h	/^    char   *wbuf;$/;"	m	struct:__anon2
wbytes	memcached.h	/^    int    wbytes;$/;"	m	struct:__anon2
wcurr	memcached.h	/^    char   *wcurr;$/;"	m	struct:__anon2
wfds	ae_select.c	/^    fd_set rfds, wfds;$/;"	m	struct:aeApiState	file:
wfileProc	ae.h	/^    aeFileProc *wfileProc;$/;"	m	struct:aeFileEvent
when_ms	ae.h	/^    long when_ms; \/* milliseconds *\/$/;"	m	struct:aeTimeEvent
when_sec	ae.h	/^    long when_sec; \/* seconds *\/$/;"	m	struct:aeTimeEvent
which	memcached.h	/^    short  which;   \/* which events were just triggered *\/$/;"	m	struct:__anon2
write_and_free	memcached.h	/^    void   *write_and_free; \/* free this memory after finishing writing *\/$/;"	m	struct:__anon2
write_and_go	memcached.h	/^    int    write_and_go; \/* which state to go into after finishing current write *\/$/;"	m	struct:__anon2
wsize	memcached.h	/^    int    wsize;$/;"	m	struct:__anon2
